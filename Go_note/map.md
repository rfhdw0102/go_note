### map
map基础知识：
```go
        //声明map
        //方式1：
	var a map[int]string
	//如果只声明map，是没有分配空间的，必须通过make初始化才会分配空间
	a = make(map[int]string, 10)
	//键值对是无序的，key不能重复，不然会覆盖value，但value是可以重复的
	//make函数的第二个参数size可以省略，默认分配一个内存
	//方式2：
	b := make(map[int]string, 10)
	//方式3：
	c := map[int]string{
		000: "张三",
		111: "李四", //注意最后也要加 “,”
	}
	//增删查改
	//增加
	b[00000] = "wwww"
	//修改
	b[00000] = "dddd"
	//删除，利用内置函数delete
	delete(b, 11111) //delete的第二个参数是key，如果key存在，删除这个键值对，若不存在，不做任何操作也不报错
	//清空
	//（麻烦）如果我们要删除map中的所有的key，没有一个专门的方法一次删除，可以遍历一下key，逐个删除
	//或者map = make（），make一个新的，让老的成为垃圾被go回收
	//查找
	value, flag := b[00000] //如果b[00000]存在，值返回value，flag为true
	//若不存在b[00000]，value为空，flag为false，不会报错
```
**map扩容机制**

1.map的底层是哈希表,采用链地址法解决哈希冲突，核心结构：
```go
type hmap struct {
    count     int       // 元素数量
    flags     uint8
    B         uint8     // 桶数量为2^B
    noverflow uint16    // 溢出桶的近似数量
    hash0     uint32    // 哈希种子
    
    buckets    unsafe.Pointer  // 桶数组，长度为2^B
    oldbuckets unsafe.Pointer  // 扩容时的旧桶数组
    nevacuate  uintptr         // 扩容进度标记
    // ...
}
```
2.触发扩容的条件

当 map 满足以下两个条件之一时，会触发扩容：
负载因子过高：当元素数量（count）超过桶数量（2^B）的 6.5 倍时,即 **count > 6.5 * 2^B**。

负载因子 = 元素数量 / 桶数量。

默认负载因子为 6.5，这是在空间和时间效率之间的平衡。
溢出桶过多：当溢出桶数量过多时（具体条件较复杂，大致为桶数量较小时溢出桶过多）。

3.扩容类型

Go 的 map 扩容分为两种类型：

**等量扩容**：

触发条件：溢出桶过多，但元素数量未超过负载因子限制。

扩容方式：桶数量不变（2^B 不变），重新排列键值对，减少溢出桶。

目的：减少内存碎片，提高访问效率。

**翻倍扩容**：

触发条件：元素数量超过负载因子限制。

扩容方式：桶数量翻倍:2^B → 2^(B+1)，重新哈希所有元素。

目的：降低负载因子，减少哈希冲突。

4.Go 的 map 扩容采用 **渐进式（incremental** 方式，而非一次性完成，以避免长时间阻塞：

创建新桶：扩容时，创建新的桶数组（翻倍或等量）。

旧桶标记：将旧桶数组保存到 oldbuckets 字段。

逐步迁移：在后续的 map 操作（如插入、删除、查找）中，每次处理 1-2 个旧桶，将其元素迁移到新桶。
完成迁移：所有旧桶迁移完成后，释放旧桶内存。
```go
func main() {
    m := make(map[int]int, 2) // 初始桶数量为2^1=2
    // 添加元素触发扩容
    for i := 0; i < 20; i++ {
        m[i] = i
        fmt.Printf("添加元素 %d: 元素数=%d, 桶数估计=2^%d\n", i, len(m), bucketCount(len(m)))
    }
}
// 估算桶数量对应的B值
func bucketCount(n int) uint8 {
    B := uint8(0)
    for 1 << B < uintptr(n/6.5) {
        B++
    }
    return B
}
//结果
添加元素 0: 元素数=1, 桶数估计=2^1
添加元素 1: 元素数=2, 桶数估计=2^1
添加元素 2: 元素数=3, 桶数估计=2^1  // 触发扩容（3 > 2*6.5/2=6.5/2≈3.25）
添加元素 3: 元素数=4, 桶数估计=2^2
...
添加元素 14: 元素数=15, 桶数估计=2^2 // 触发扩容（15 > 4*6.5=26）
添加元素 15: 元素数=16, 桶数估计=2^3
```
5.关键点总结：

1）.负载因子平衡：
负载因子 6.5 是时间和空间的平衡点，过高会增加冲突，过低会浪费内存。

2）.渐进式扩容优势：
避免一次性扩容的长时间停顿，保证 map 操作的响应性。

3）.并发限制：
map 不是并发安全的，扩容期间若多个 goroutine 同时操作，可能导致 panic。

4）.预分配优化：
若预先知道 map 的大致元素数量，可通过 make(map[T]U, size) 预分配，减少扩容次数。

6.与切片扩容的对比
| 特性 | map 扩容 | 切片扩容 |
| :---: | :---: | :---:|
| 触发条件 | 负载因子 > 6.5 或溢出桶过多 | 元素数量超过容量 |
| 扩容方式 | 翻倍或等量，渐进式迁移 | 直接分配新数组，一次性复制 |
| 内存管理 | 更复杂（涉及旧桶逐步释放） | 简单（旧数组丢弃） |
| 并发安全 | 非并发安全，需手动同步 | 非并发安全，需手动同步 |	