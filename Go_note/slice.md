### 切片
Go里面特有的数据类型, 是对数组一个连续片段的引用，是一个引用类型, 提供了一个相关数组的动态窗口.

数组有特定的用处，但是长度固定不可变，有些呆板，不常用，但切片更常用，他是建立咋数组之上的抽象，有更强大的能力和便捷性
```go
    //切片定义之后不能直接使用，需要让其引用到一个数组，或者make一个空间来使用
    //eg:var slice []int  不能直接使用(不能赋值)
    //声明/定义
    var intarr = [5]int{1, 2, 3, 4, 5}
    //1.切片定义在数组之上
    var slice []int = intarr[1:4] //简写为var slice = intarr{1:}
    var slice = intarr[0:len(intarr)] //var slice = intarr[:]
    varvar slice = intarr[0:3] //var slice = intarr[:3] 
    //2.利用make，make函数的三个参数（1。切片类型，2.切片长度，3.切片容量）
    //make函数底层创建一个数组，数组不可见
    slice := make([]int, 10, 20)//长度一定小于等于容量
    //3.直接指定具体数组，使用原理类似make的方式
    slice := []int{1, 4, 7}
```
切片的一些常用的方法
```go
    len(slice)//返回长度
    cap(slice)//返回容量
    //切片可以继续切片，也可追加元素
    newSlice := slice[1:5]//继续切片
    slice = append(slice, 88, 99)//追加元素
    //也可以通过切片追加切片
    slice = append(slice, slice1...)//要带...，意思就是将一个切片的所有元素展开，这是因为切片是 [ ]int 类型，而 append 要求接收的参数是 int 类型，如果直接传入 slice1 会报错
    //遍历
    //1.for循环
    for i := 0; i < len(slice); i++ {
	    fmt.Println(slice[i])
    }
    //2.for-range
    for _, value := range slice {
	    fmt.Print(value)
    }
```
**切片的扩容机制**
切片是一个结构体（了解）
```go
type slice struct {
    array unsafe.Pointer // 指向底层数组
    len   int            // 切片长度
    cap   int            // 切片容量
}
```
重点：

当切片追加元素时，如使用append函数，若len超过了cap，则会触发扩容

**Go 1.18 之前**：扩容策略为：

若新长度（len + 新增元素数）超过当前容量的 2 倍：直接扩容至新长度。 

小于 1024 时翻倍。
大于 1024 时每次增加 25%，直到满足新长度要求

扩容完成之后，会进行内存对齐，主要通过向上取整到 8 字节的倍数实现

**Go 1.18+**：

Go1.18不再以1024为临界点，而是设定了一个值为256的threshold，以256为临界点；超过256，不再是每次扩容1/4，而是每次增加（旧容量+3*256）/4；其中cap为预期容量，也就是说添加了数据之后需要的容量

当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容；

当原 slice 容量 < threshold 的时候，新 slice 容量变成原来的 2 倍；

当原 slice 容量 > threshold，进入一个循环，每次容量增加（旧容量+3*threshold）/4。

内存对齐：Go 1.18 引入了更精细的内存块分级，将内存划分为约 70 种不同规格，覆盖从 8 字节到 32KB 的范围。

小对象：8, 16, 24, 32, 48, 64, 80, ..., 512 字节
中等对象：576, 640, 704, 768, ..., 32768 字节
当计算出理论容量后，Go 会选择最接近且大于等于该容量的内存块规格作为实际容量。

对于内存大于32KB的称为大对象，会单独处理.
